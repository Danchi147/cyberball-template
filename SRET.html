<script>
  const TRAITS = [
    "Affectionate","Caring","Communicative","Warm","Polite","Outgoing","Open","Loyal",
    "Sociable","Supportive","Sympathetic","Tolerant","Trustworthy","Understanding",
    "Altruistic","Fair","Friendly","Helpful","Honest","Considerate","Moral","Reliable",
    "Conscientious","Agreeable","Able","Ambitious","Assertive","Capable","Competent",
    "Active","Determined","Confident","Vigorous","Intelligent","Strong","Creative",
    "Persistent","Rational","Self-reliant","Independent","Industrious","Energetic",
    "Prominent","Successful","Leader","Influential","Charismatic","Enthusiastic"
  ];

  const FIXATION_MS = 500;

  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  function nowMs() { return performance.now(); }

  const scrInstr = document.getElementById("screen-instructions");
  const scrTask  = document.getElementById("screen-task");
  const scrDone  = document.getElementById("screen-finish");

  const stimEl   = document.getElementById("stimulus");
  const fixEl    = document.getElementById("fixation");
  const progBar  = document.getElementById("progress-bar");
  const ynHint   = document.getElementById("yn-hint");

  function show(screen) {
    scrInstr.classList.add("hidden");
    scrTask.classList.add("hidden");
    scrDone.classList.add("hidden");
    screen.classList.remove("hidden");
  }

  function renderStimulus(text) {
    stimEl.textContent = text;
    stimEl.classList.remove("hidden");
    fixEl.classList.add("hidden");
    ynHint.classList.remove("hidden"); // show V/N only with stimulus
  }

  function renderFixation() {
    stimEl.classList.add("hidden");
    fixEl.classList.remove("hidden");
    ynHint.classList.add("hidden"); // hide V/N during fixation
  }

  function setProgress(curIndex, total) {
    const pct = total ? (curIndex / total) * 100 : 0;
    progBar.style.width = pct + "%";
  }

  // ===== Focus trap (keyboard reliability inside iframe) =====
  const focusTrap = document.createElement("input");
  focusTrap.setAttribute("type", "text");
  focusTrap.setAttribute("aria-hidden", "true");
  focusTrap.autocomplete = "off";
  focusTrap.style.position = "fixed";
  focusTrap.style.opacity = "0";
  focusTrap.style.left = "-9999px";
  focusTrap.style.top = "0";
  document.body.appendChild(focusTrap);

  function grabFocus() {
    try { focusTrap.focus({ preventScroll: true }); } catch(e) { try { focusTrap.focus(); } catch(_) {} }
  }

  window.addEventListener("load", () => {
    // attempt to focus automatically
    grabFocus();
    // keep focus (some browsers steal it)
    window.setInterval(() => {
      if (document.activeElement !== focusTrap) grabFocus();
    }, 500);
  });

  // ===== Task state =====
  const sessionId = (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
  let trials = [];
  let tIndex = -1;
  let currentTrait = null;
  let stimOnsetMs = null;

  let acceptingResponse = false;
  let started = false;

  const taskLog = {
    task: "SRET",
    version: "sret_v1_keyboard_only_enter_start_vn_yesno_visibleYN",
    session_id: sessionId,
    started_iso: null,
    finished_iso: null,
    n_trials: null,
    fixation_ms: FIXATION_MS,
    trials: []
  };

  function startTask() {
    trials = shuffle(TRAITS);
    tIndex = -1;
    taskLog.started_iso = new Date().toISOString();
    taskLog.trials = [];
    show(scrTask);
    nextTrial();
  }

  function nextTrial() {
    tIndex += 1;
    setProgress(tIndex, trials.length);

    if (tIndex >= trials.length) {
      finishTask();
      return;
    }

    currentTrait = trials[tIndex];
    acceptingResponse = true;          // open gate only during stimulus
    renderStimulus(currentTrait);
    stimOnsetMs = nowMs();
  }

  function recordResponse(resp) {
    if (!acceptingResponse) return;
    acceptingResponse = false;         // close gate immediately

    const rtMs = Math.round(nowMs() - stimOnsetMs);

    taskLog.trials.push({
      trial_index: tIndex + 1,         // order of presentation
      trait: currentTrait,
      response: resp,                  // "Yes"/"No"
      rt_ms: rtMs,
      response_time_iso: new Date().toISOString()
    });

    renderFixation();
    window.setTimeout(nextTrial, FIXATION_MS);
  }

  function finishTask() {
    taskLog.finished_iso = new Date().toISOString();
    taskLog.n_trials = trials.length;

    show(scrDone);

    window.parent.postMessage(
      { type: "SRET_Log_v1", taskLog: taskLog },
      "*"
    );
  }

  // ===== Keyboard handler (document-level) =====
  document.addEventListener("keydown", (e) => {
    // keep focus
    if (document.activeElement !== focusTrap) grabFocus();

    // Start on Enter (instructions screen)
    if (!started) {
      if (!scrInstr.classList.contains("hidden") && e.key === "Enter") {
        started = true;
        startTask();
      }
      return;
    }

    if (scrTask.classList.contains("hidden")) return;
    if (!acceptingResponse) return;

    const k = e.key.toLowerCase();
    if (k === "v") recordResponse("Yes");
    else if (k === "n") recordResponse("No");
  }, true);

  // Initial
  show(scrInstr);
</script>
