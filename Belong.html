<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Belonging: Reward–Threat Curve (Interactive)</title>
<style>
  :root{
    --bg:#ffffff;
    --panel:#ffffff;
    --ink:#111111;
    --muted:#444444;
    --accent:#10b981; /* green for reward */
    --accent2:#1d4ed8; /* blue for reference line */
    --threat:#ef4444; /* red for threat */
    --grid:#e5e7eb; /* light grey grid */
    --axis:#111111; /* axis and tick */
    --border:#d1d5db; /* panel border */
    --ff: Georgia, "Times New Roman", Times, serif;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--ink); font:16px/1.5 var(--ff);
  }
  .wrap{max-width:1100px; margin:24px auto; padding:0 16px;}
  h1{font-size:clamp(20px, 3vw, 28px); margin:0 0 12px; letter-spacing:0.2px}
  .grid{display:grid; grid-template-columns: 360px 1fr; gap:18px; align-items:start;}
  @media (max-width: 920px){.grid{grid-template-columns: 1fr}}
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px}
  .controls h2{font-size:18px; margin:4px 0 8px}
  .row{display:grid; grid-template-columns: 1fr 110px; gap:10px; align-items:center; margin:12px 0}
  .row label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px}
  input[type="range"], input[type="number"], button, label, .legend, .readout{font-family: var(--ff);}
  input[type="range"]{width:100%}
  input[type="number"]{width:100%; padding:8px 10px; background:#fff; color:var(--ink); border:1px solid var(--border); border-radius:10px;}
  .buttons{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
  button{background:#fff; border:1px solid var(--border); color:var(--ink); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600}
  button.primary{border-color:#93c5fd}
  .canvas-panel{position:relative}
  svg{width:100%; height:auto; display:block; font-family: var(--ff);}
  .legend{display:flex; gap:18px; align-items:center; flex-wrap:wrap; margin-top:8px; color:var(--muted)}
  .chip{display:inline-flex; align-items:center; gap:8px}
  .chip i{display:inline-block; width:20px; height:4px; border-radius:2px}
  .chip .reward{background:var(--accent)}
  .chip .threat{background:var(--threat)}
  .readout{margin-top:8px; color:var(--muted)}
  .mono{font-family: var(--ff); font-weight:600; color:var(--ink)}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Belonging: Reward–Threat Curve</h1>

    <div class="grid">
      <!-- Controls -->
      <div class="panel controls">
        <h2>Parameters</h2>

        <div class="row">
          <div>
            <label for="satiation">Satiation point (X, %): <span id="satiationLabel" class="mono">50</span></label>
            <input id="satiation" type="range" min="0" max="100" step="1" value="50" />
          </div>
          <input id="satiationNum" type="number" min="0" max="100" step="1" value="50" />
        </div>

        <div class="row">
          <div>
            <label for="alpha">Social threat sensitivity α (curvature): <span id="alphaLabel" class="mono">0.88</span></label>
            <input id="alpha" type="range" min="0.2" max="2" step="0.02" value="0.88" />
          </div>
          <input id="alphaNum" type="number" min="0.2" max="2" step="0.02" value="0.88" />
        </div>

        <div class="row">
          <div>
            <label for="beta">Social reward sensitivity β (curvature): <span id="betaLabel" class="mono">0.88</span></label>
            <input id="beta" type="range" min="0.2" max="2" step="0.02" value="0.88" />
          </div>
          <input id="betaNum" type="number" min="0.2" max="2" step="0.02" value="0.88" />
        </div>

        <div class="buttons">
          <button class="primary" id="resetBtn" title="Reset to defaults">Reset</button>
          <button id="downloadBtn" title="Save SVG as file">Download SVG</button>
        </div>
      </div>

      <!-- Chart -->
      <div class="panel canvas-panel">
        <svg id="chart" viewBox="0 0 960 560" role="img" aria-label="Reward–Threat curve chart"></svg>
        <div class="legend">
          <span class="chip"><i class="reward"></i> Social Reward (Need‑Fulfillment)</span>
          <span class="chip"><i class="threat"></i> Social Threat</span>
        </div>
        <div class="readout small" id="readout"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  // SVG & layout
  const svg = document.getElementById('chart');
  const NS = 'http://www.w3.org/2000/svg';
  const W = 960, H = 560;
  const M = {top: 28, right: 24, bottom: 56, left: 72};
  const innerW = W - M.left - M.right;
  const innerH = H - M.top - M.bottom;

  // Layers
  const gRoot = el('g', {transform: `translate(${M.left},${M.top})`});
  const gGrid = el('g', {class: 'grid'});
  const gAxes = el('g', {class: 'axes'});
  const gCurve = el('g', {class: 'curve'});
  const gOverlay = el('g', {class: 'overlay'});
  svg.appendChild(gRoot);
  gRoot.appendChild(gGrid);
  gRoot.appendChild(gAxes);
  gRoot.appendChild(gCurve);
  gRoot.appendChild(gOverlay);

  // Styles in-SVG (for crisp print/export)
  const style = el('style', {});
  style.textContent = `
    text { font-family: Georgia, 'Times New Roman', Times, serif; }
    .axes line, .axes path { stroke: var(--axis); }
    .grid line { stroke: var(--grid); }
    .axis-label { fill: var(--axis); font-size: 12px; }
    .tick text { fill: var(--axis); font-size: 12px; }
    .tick line { stroke: var(--axis); }
    .curve path.reward { stroke: var(--accent); stroke-width: 3; fill: none; }
    .curve path.threat { stroke: var(--threat); stroke-width: 3; fill: none; }
    .ref-line { stroke: var(--accent2); stroke-width: 2; stroke-dasharray: 6 6; }
    .zero-line { stroke: #9ca3af; stroke-dasharray: 4 6; }
    .sample-dot { fill: var(--axis); stroke: var(--axis); stroke-width: 1.5; r: 3.5; }
    .sample-guide { stroke: #9ca3af; stroke-width: 1; stroke-dasharray: 3 5; }
    .hover-rect { fill: transparent; cursor: crosshair; }
  `;
  svg.appendChild(style);

  // Controls
  const controls = {
    s: bindPair('satiation', 'satiationNum', 'satiationLabel', v => clamp(+v, 0, 100), 50),
    alpha: bindPair('alpha', 'alphaNum', 'alphaLabel', v => clamp(+v, 0.2, 2), 0.88),
    beta: bindPair('beta', 'betaNum', 'betaLabel', v => clamp(+v, 0.2, 2), 0.88),
  };

  document.getElementById('resetBtn').addEventListener('click', () => {
    controls.s.set(50);
    controls.alpha.set(0.88);
    controls.beta.set(0.88);
    draw();
  });

  document.getElementById('downloadBtn').addEventListener('click', () => {
    const data = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'belonging-reward-threat-curve.svg'; a.click();
    URL.revokeObjectURL(url);
  });

  const readout = document.getElementById('readout');

  // Scales
  const xScale = x => x/100 * innerW;
  const yScale = (y, ymin, ymax) => innerH - ( (y - ymin) / (ymax - ymin) ) * innerH;

  function valueAt(x, s, alpha, beta){
    if (x >= s){
      const d = x - s;
      const rng = Math.max(100 - s, 1e-9);
      const norm = d / rng; // 0..1
      return Math.pow(norm, beta); // up to +1 (reward)
    } else {
      const d = s - x;
      const rng = Math.max(s, 1e-9);
      const norm = d / rng; // 0..1
      return -Math.pow(norm, alpha); // down to -1 (threat)
    }
  }

  function niceTicks(min, max, count=6){
    const span = max - min;
    if (!isFinite(span) || span <= 0){ return [min, max]; }
    const step0 = span / Math.max(1, count);
    const mag = Math.pow(10, Math.floor(Math.log10(step0)));
    const err = step0 / mag;
    let step;
    if (err >= 5) step = 10*mag; else if (err >= 2) step = 5*mag; else if (err >= 1) step = 2*mag; else step = mag;
    const niceMin = Math.floor(min/step)*step;
    const niceMax = Math.ceil(max/step)*step;
    const ticks = [];
    for (let t = niceMin; t <= niceMax + 1e-9; t += step){ ticks.push(+t.toFixed(6)); }
    return ticks;
  }

  function draw(){
    // Read params
    const s = controls.s.get();
    const alpha = controls.alpha.get();
    const beta = controls.beta.get();

    // Y extents (±1 with a little padding)
    const yMax = 1.0;
    const yMin = -1.0;
    const pad = (yMax - yMin) * 0.08;
    const ymin = yMin - pad, ymax = yMax + pad;

    // Clear groups
    gGrid.innerHTML = ''; gAxes.innerHTML = ''; gCurve.innerHTML = ''; gOverlay.innerHTML='';

    // Grid + axes
    // X ticks (0..100)
    const xTicks = [0,10,20,30,40,50,60,70,80,90,100];
    xTicks.forEach(tx => {
      const x = xScale(tx);
      gGrid.appendChild(line(x, 0, x, innerH, 'var(--grid)'));
      const t = el('g', {class:'tick'});
      t.appendChild(line(x, innerH, x, innerH+6, 'var(--axis)'));
      const lbl = el('text', {x: x, y: innerH+22, 'text-anchor':'middle'});
      lbl.textContent = tx;
      t.appendChild(lbl);
      gAxes.appendChild(t);
    });

    // Y ticks
    const yTicks = niceTicks(ymin, ymax, 6).filter(v => isFinite(v));
    yTicks.forEach(ty => {
      const y = yScale(ty, ymin, ymax);
      gGrid.appendChild(line(0, y, innerW, y, 'var(--grid)'));
      const t = el('g', {class:'tick'});
      t.appendChild(line(-6, y, 0, y, 'var(--axis)'));
      const lbl = el('text', {x: -10, y: y+4, 'text-anchor':'end'});
      lbl.textContent = roundSmart(ty);
      t.appendChild(lbl);
      gAxes.appendChild(t);
    });

    // Axis lines
    gAxes.appendChild(line(0, innerH, innerW, innerH, 'var(--axis)')); // x
    gAxes.appendChild(line(0, 0, 0, innerH, 'var(--axis)')); // y

    // Axis labels
    const xLab = el('text', {class:'axis-label', x: innerW/2, y: innerH+40, 'text-anchor':'middle'});
    xLab.textContent = 'Social attention (% participation)';
    gAxes.appendChild(xLab);

    const yLab = el('text', {class:'axis-label', x: -M.left+8, y: -12});
    yLab.textContent = 'Need‑Fulfillment (+) / Threat (−)';
    gAxes.appendChild(yLab);

    // Zero line
    const y0 = yScale(0, ymin, ymax);
    const zero = line(0, y0, innerW, y0, null);
    zero.setAttribute('class','zero-line');
    gAxes.appendChild(zero);

    // Vertical reference line at s
    const xs = xScale(s);
    const ref = line(xs, 0, xs, innerH, null);
    ref.setAttribute('class','ref-line');
    gAxes.appendChild(ref);

    const refLbl = el('text', {x: xs+6, y: 16, fill: 'var(--muted)'});
    refLbl.textContent = `Satiation = ${s}%`;
    gAxes.appendChild(refLbl);

    // Curve paths (split at s so we can color differently)
    const pathReward = el('path', {class:'reward'});
    const pathThreat = el('path', {class:'threat'});
    let dReward = '', dThreat = '';

    for (let x=0; x<=100; x+=1){
      const yVal = valueAt(x, s, alpha, beta);
      const X = xScale(x), Y = yScale(yVal, ymin, ymax);
      if (x === 0){
        dThreat += `M ${X} ${Y}`;
      } else {
        if (x <= s){ dThreat += ` L ${X} ${Y}`; }
      }
    }
    // Build reward from s to 100
    for (let x=Math.max(0, Math.floor(s)); x<=100; x+=1){
      const yVal = valueAt(x, s, alpha, beta);
      const X = xScale(x), Y = yScale(yVal, ymin, ymax);
      if (x === Math.max(0, Math.floor(s))){ dReward += `M ${X} ${Y}`; }
      else { dReward += ` L ${X} ${Y}`; }
    }

    pathThreat.setAttribute('d', dThreat);
    pathReward.setAttribute('d', dReward);
    gCurve.appendChild(pathThreat);
    gCurve.appendChild(pathReward);

    // Hover sampling
    const hoverRect = el('rect', {class:'hover-rect', x:0, y:0, width:innerW, height:innerH});
    gOverlay.appendChild(hoverRect);

    const vGuide = line(0,0,0,innerH,null); vGuide.setAttribute('class','sample-guide'); vGuide.style.opacity=0;
    const hGuide = line(0,0,innerW,0,null); hGuide.setAttribute('class','sample-guide'); hGuide.style.opacity=0;
    const dot = el('circle', {class:'sample-dot', cx:0, cy:0, r:3.5}); dot.style.opacity=0;
    gOverlay.appendChild(vGuide); gOverlay.appendChild(hGuide); gOverlay.appendChild(dot);

    hoverRect.addEventListener('mousemove', (e) => {
      const pt = clientToSvg(e.clientX, e.clientY);
      const xLocal = Math.max(0, Math.min(innerW, pt.x - M.left));
      const xVal = (xLocal/innerW) * 100;
      const yVal = valueAt(xVal, s, alpha, beta);
      const X = xLocal, Y = yScale(yVal, ymin, ymax);
      vGuide.setAttribute('x1', X); vGuide.setAttribute('x2', X);
      hGuide.setAttribute('y1', Y); hGuide.setAttribute('y2', Y);
      dot.setAttribute('cx', X); dot.setAttribute('cy', Y);
      vGuide.style.opacity = hGuide.style.opacity = dot.style.opacity = 1;
      readout.innerHTML = `x = <span class="mono">${xVal.toFixed(1)}%</span>, v(x) = <span class="mono">${yVal.toFixed(3)}</span>`;
    });

    hoverRect.addEventListener('mouseleave', () => {
      vGuide.style.opacity = hGuide.style.opacity = dot.style.opacity = 0;
      readout.textContent = '';
    });
  }

  // Helpers
  function el(tag, attrs){
    const n = document.createElementNS(NS, tag);
    for (const k in attrs){ n.setAttribute(k, attrs[k]); }
    return n;
  }
  function line(x1,y1,x2,y2,stroke){
    const L = el('line', {x1, y1, x2, y2});
    if (stroke) L.setAttribute('stroke', stroke);
    return L;
  }
  function roundSmart(v){
    const a = Math.abs(v);
    if (a === 0) return '0';
    if (a < 0.001) return v.toExponential(1);
    if (a < 1) return v.toFixed(2);
    if (a < 10) return v.toFixed(2);
    return v.toFixed(0);
  }
  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  function clientToSvg(clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const m = svg.getScreenCTM().inverse();
    return pt.matrixTransform(m);
  }

  function bindPair(rangeId, numId, labelId, coerce, initial){
    const r = document.getElementById(rangeId);
    const n = document.getElementById(numId);
    const l = document.getElementById(labelId);

    function set(val){
      const v = coerce(val);
      r.value = String(v); n.value = String(v); l.textContent = String(v);
    }
    function get(){ return coerce(r.value); }

    function onInput(){ set(r.value); draw(); }
    function onNum(){ set(n.value); draw(); }

    r.addEventListener('input', onInput);
    n.addEventListener('input', onNum);
    set(initial);

    return {get, set};
  }

  // Initial render
  draw();
})();
</script>
</body>
</html>
